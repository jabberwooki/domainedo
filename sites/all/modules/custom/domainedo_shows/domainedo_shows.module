<?php
/**
 * @file
 * Code for the Domaine d'O Spectacles feature.
 */

include_once 'domainedo_shows.features.inc';

/**
 * Implements hook_init().
 */
function domainedo_shows_init() {
    drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_shows.js');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function domainedo_shows_form_show_node_form_alter(&$form, &$form_state, $form_id) {
	// Vertical tab "Lien distribution" moved to bottom of existing tabs in create/edit form.
	$form['#groups']['group_casting']->weight = 1000;
}

/**
 * Implements hook_node_view_alter().
 */
function domainedo_shows_node_view_alter(&$build) {
	// If show node
  $now = date('Y-m-d');
  $now = new DateTime( $now );
  $now = $now->format('Ymd'); 
  $show_is_past;
  
	if ($build['#bundle'] == 'show') {		
		// Processing of festival's name in List view mode.
		if ($build['#view_mode'] == 'list' && isset($build['field_festival'][0]['#markup'])) {
			$festival_infos = domainedo_shows_get_festival_infos($build['field_festival'][0]['#markup'], array('title'));
			if (!empty($festival_infos)) {
				$build['field_festival'][0]['#markup'] = $festival_infos['title'];
			}
			else {
				unset($build['field_festival']);
			}
		}
		if ($build['#view_mode'] == 'liste_aussi') {
      $show_is_past = false;
      for ($i = 0; $i < count($build['field_show_dates']['#items']); $i++) {    
          $show_date_item = $build['field_show_dates']['#items'][$i]['value'];
          $show_date_item = substr($show_date_item, 0, 10);
          $show_date_item = new DateTime( $show_date_item );
          $show_date_item = $show_date_item->format('Ymd');
          
          if ($now <= $show_date_item) {
            $show_is_past  = false; 
            break;
          } else {
            $show_is_past = true;
          }
        }
        if ($show_is_past) $build = null;
      
    }
		if ($build['#view_mode'] == 'full') {
			// Breadcrumb processing : if the show node is requested from a festival page,
			// the breadcrumb link 'Tous les spectacles' must send user to the shows list
			// filtered on the latest edition of the same festival.
			$url_elements = explode('/', $_SERVER['HTTP_REFERER']);
			// If the fourth element of the referer url contains a festival name, then we come from a festival page.
			if (isset($url_elements[4]) && in_array($url_elements[4], array_keys(domainedo_shows_get_festivals()))) {
				$festival_values = domainedo_shows_get_latest_festival_values($url_elements[4]);
				$latest_festival_id = $festival_values['nid'];
				$breadcrumb = drupal_get_breadcrumb();
				$modified_url = url('spectacles/tous-les-spectacles', array('query' => array('field_festival_target_id' => $latest_festival_id)));
				$modified_link = '<a href="' . $modified_url . '">Tous les spectacles</a>';
				$breadcrumb[2] = $modified_link;
				drupal_set_breadcrumb($breadcrumb);
			}
			
			//Puts a link on Festival name, except for festival-hiver.
			if (isset($build['field_festival'])) {
				$festival_infos = domainedo_shows_get_festival_infos($build['field_festival']['#items'][0]['target_id'], array('title', 'url'));
				if (!empty($festival_infos)) {
					$build['field_festival'][0]['#markup'] = '<a href="/' . $festival_infos['url'] . '">' . $build['field_festival'][0]['#markup'] . '</a>';
				}
			}
			
			// Manage display of fields depending on Reservation value : prochainement=1, url billetterie=2, complet=3, annulé=4)
			$field_reservation_value = $build['field_reservation']['#items'][0]['value'];
      
      /* In the case where the link to ticketing is enable and the show went,
       * we automaticly enable the "passed" option : $field_reservation_value = 5;
      */
      
      
      $show_has_ticket_link = (isset($build['field_reservation']) && $build['field_reservation']['#items'][0]['value'] == 2);
      if ($show_has_ticket_link && isset($build['field_show_dates']['#items'])){   
        $show_is_past = false;
        for ($i = 0; $i < count($build['field_show_dates']['#items']); $i++) {    
          $show_date_item = $build['field_show_dates']['#items'][$i]['value'];
          $show_date_item = substr($show_date_item, 0, 10);
          $show_date_item = new DateTime( $show_date_item );
          $show_date_item = $show_date_item->format('Ymd');
          
          if ($now <= $show_date_item) {
            $show_is_past  = false; 
            break;
          } else {
            $show_is_past = true;
          }
        }
      }
      if ($show_is_past) $field_reservation_value = 5;
			$dependent_fields = array(
					'1' => 'field_coming_soon',
					'2' => 'field_boxoffice_url',
					'3' => 'field_full',
					'4' => 'field_reimbursement',
					'6' => 'field_offline',
			);
			foreach ($dependent_fields as $key=>$field_name) {
				if ($key != $field_reservation_value) {
					unset($build[$field_name]);
				}
			}
			
			// Manage display of link Distribution
			if (!isset($build['field_casting'])) {
				unset($build['field_casting_link']);
			}
			
			// Processing of field Reservation when its value is 'annulé'.
			if (isset($build['field_reservation']) && $build['field_reservation']['#items'][0]['value'] == 4) {
				$start_tag = '';
				$end_tag = '';
				if ($build['#view_mode'] == 'full') {
					$start_tag = '<h3>';
					$end_tag = '</h3>';
				}
				if ($build['#view_mode'] == 'list') {
					$start_tag = '<h4>';
					$end_tag = '</h4>';
				}
				$build['field_reservation'][0]['#markup'] = $start_tag . $build['field_reservation'][0]['#markup'] . $end_tag;
			}
			
			// Displays video, sound and photos links only if corresponding fields contain data.
			if (!isset($build['field_scald_video'])) {
				unset($build['field_video_link']);
			}
			if (!isset($build['field_scald_sound'])) {
				unset($build['field_sound_link']);
			}
			if (!isset($build['field_scald_gallery'])) {
				unset($build['field_photos_link']);
			}
		}
	}
}

/**
 * Returns the list of managed festivals.
 * 
 * @return array Festivals.
 */
function domainedo_shows_get_festivals() {
	$festivals = array(
			'saperlipopette' => array('title' => 'Saperlipopette', 'weight' => 11, 'url' => 'spectacles/saperlipopette'),
			'printemps-des-comediens' => array('title' => 'Printemps des comédiens', 'weight' => 12, 'url' => 'spectacles/printemps-des-comédiens'),
			'folies-do' => array('title' => 'Folies d\'O', 'weight' => 13, 'url' => 'spectacles/folies-do'),
			'radio-france' => array('title' => 'Radio France', 'weight' => 14, 'url' => 'spectacles/radio-france'),
			'nuits-do' => array('title' => 'Nuits d\'O', 'weight' => 15, 'url' => 'spectacles/nuits-do'),
			'arabesques' => array('title' => 'Arabesques', 'weight' => 16, 'url' => 'spectacles/arabesques'),
			'festival-hiver' => array('title' => 'Festival d\'hiver', 'weight' => 17, 'url' => 'spectacles/festival-dhiver'),
      'nuit-gitane' => array('title' => 'Nuit Gitane', 'weight' => 18, 'url' => 'spectacles/nuit-gitane'),
	);
	
	return $festivals;
}

/** 
 * Returns the Festival name of a given edition
 * 
 * @param int Nid of the Festival edition.
 * @param array An array containing the requested info types.
 * @return array Array containing requested festival info values.
 */
function domainedo_shows_get_festival_infos($edition_id, $info_types) {
	$query = db_select('node', 'n');
	$query->join('field_data_field_festival_name', 'f', 'n.nid = f.entity_id');
	
	$query->addField('f', 'field_festival_name_value', 'name');
	$query->condition('n.nid', $edition_id);

	$result = $query->execute()->fetchField();//
	
	if ($result != 'festival-hiver') {
		$festivals = domainedo_shows_get_festivals();
		$info_values = array('title' => '', 'url' => '');
		foreach ($info_types as $type) {
			$info_values[$type] = $festivals[$result][$type];
		}
		return $info_values;
	}
	return null;
}

/**
 * Returns the latest festival (latest season) of a given festival name.
 * 
 * @param string $festival_name The name of the festival.
 * @param int $ignored_id Nid of the festival edition to be ignored.
 * @return int Nid of the latest festival.
 */
function domainedo_shows_get_latest_festival_values($festival_name, $ignored_id=FALSE) {
	$query = db_select('node', 'n');
	$query->join('field_data_field_festival_name', 'f', 'n.nid = f.entity_id');
	$query->join('field_data_field_season', 's', 'n.nid = s.entity_id');
	
	$query->addField('n', 'nid');
	$query->addField('f', 'field_festival_name_value', 'name');
	$query->addField('s', 'field_season_value', 'season');
	$query->condition('n.type', 'festival')
	->condition('f.field_festival_name_value', $festival_name)
	->condition('n.status', '1');
	
	$result = $query->execute()->fetchAll();
	
	$festival_values = array();
	foreach ($result as $festival) {
		if ($ignored_id && $festival->nid == $ignored_id) continue;
		$festival_values[$festival->season] = $festival->nid;
	}
	krsort($festival_values);
	return array('nid' => current($festival_values), 'season' => key($festival_values));
}

/**
 * Implements hook_node_validate().
 */
function domainedo_shows_node_validate($node, $form, &$form_state) {
	if ($node->type == 'festival') {
		// If we are trying to save a new node
		if (!$form_state['values']['nid']) {
			$query = new EntityFieldQuery();
			$query->entityCondition('entity_type', 'node')
			->entityCondition('bundle', 'festival')
			->fieldCondition('field_season', 'value', $form_state['values']['field_season']['und'][0]['value'])
			->fieldCondition('field_festival_name', 'value', $form_state['values']['field_festival_name']['und'][0]['value'])
			->count();
			
			$count = $query->execute();
			// and the same festival already exists
			if ($count > 0) {
				form_set_error('festival_unique', t('This festival edition already exists.'));
			}
		}
	}
}

/**
 * Implements hook_node_presave().
 */
function domainedo_shows_node_presave($node) {
	// If node is festival, we must manage menu links.
	if ($node->type == 'festival') {
		///////////////// 1st SITUATION - INSERTION OF A NEW FESTIVAL ////////////////////////////////
		if ($node->is_new) {
			// If the festival is the latest one,
			if ($previous_festival_values = is_latest_festival($node)) {
				// a new menu link is prepared,
				$festivals = domainedo_shows_get_festivals();
				$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
				$node->menu['link_title'] = $festivals[$node->field_festival_name['und'][0]['value']]['title'];
				$node->menu['plid'] = $mlid;
				$node->menu['weight'] = $festivals[$node->field_festival_name['und'][0]['value']]['weight'];
				$node->menu['parent'] = 'parent:' . $mlid;;
				$node->menu['enabled'] = 1;
				$node->menu['description'] = '';
				
				// If a previous festival exists,
				if(!is_bool($previous_festival_values)) {
					list($previous_festival_nid, $previous_festival_season) = $previous_festival_values;
					// its menu link is deleted
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $previous_festival_nid,))->fetchField();
					menu_link_delete($mlid);
					
					// and its path alias is changed from "spectacles/festival-name" to "spectacles/festival-name/season-value".
					$festival_data = array_merge($previous_festival_values, array($node->field_festival_name['und'][0]['value']));
					domainedo_shows_festival_pathalias_update($festival_data);
				}
			}
			// If it's not the latest one,
			else {
				// No menu link to build, but its path alias must be "spectacles/festival-name/season-value".
				$node->path['alias'] = 'spectacles/' . $node->field_festival_name['und'][0]['value'] . '/' . $node->field_season['und'][0]['value'];
				// and we must deactivate the pathauto mechanism, 
				// otherwise it will replace the $node->path['alias'] we've just built
				// by its own value, that is with no trailing season value.
				$node->path['pathauto'] = 0;
			}
		}
		////////////////////// 2nd SITUATION - UPDATE OF AN EXISTING FESTIVAL ////////////////////////////
		else {
			// Two data have to be figured out :
			// - the menu link
			// - the path alias
			// We must act only if festival name and/or season value have been altered, so let's test it first.
			$is_festival_name_modified = FALSE;
			$is_season_modified = FALSE;
			
			if ($node->field_season['und'][0]['value'] != $node->original->field_season['und'][0]['value']) {
				$is_season_modified = TRUE;
			}
			if ($node->field_festival_name['und'][0]['value'] != $node->original->field_festival_name['und'][0]['value']) {
				$is_festival_name_modified = TRUE;
			}
			
			// If festival name and/or season value have been altered, we must act !
			if ($is_festival_name_modified || $is_season_modified) {
				// If the festival being updated IS THE LATEST ONE, 
				if ($previous_festival_values = is_latest_festival($node, FALSE)) {
					// its menu link must be built (or rebuilt).
					// So, the existing menu link, if any, is deleted
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $node->nid,))->fetchField();
					if ($mlid) {
						menu_link_delete($mlid);
					}
					else {
						dsm('pas de lien de menu à supprimer');
					}
					// a new menu link is prepared
					$festivals = domainedo_shows_get_festivals();
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
					$node->menu['link_title'] = $festivals[$node->field_festival_name['und'][0]['value']]['title'];
					$node->menu['plid'] = $mlid;
					$node->menu['weight'] = $festivals[$node->field_festival_name['und'][0]['value']]['weight'];
					$node->menu['parent'] = 'parent:' . $mlid;;
					$node->menu['enabled'] = 1;
					$node->menu['description'] = '';
					
					// and its path alias must be updated to "spectacles/festival-name".
					$node->path['pathauto'] = 0;
					$node->path['alias'] = 'spectacles/' . $node->field_festival_name['und'][0]['value'];
					
					// If season value has changed, that means that the previous festival was the latest one before current update.
					// Note : if there is only one festival in the current category (festival name), 
					// the function is_latest_festival() returns the boolean TRUE instead of an array of values. 
					// In that case, nothing to do. So we must test it as well.
					if ($is_season_modified && !is_bool($previous_festival_values)) {
						list($previous_festival_id, $previous_festival_season) = $previous_festival_values;
						// The previous festival's menu link must be deleted
						$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $previous_festival_id,))->fetchField();
						
						// and its path alias must be "spectacles/festival-name/season-value".
						$previous_festival_values = array_merge($previous_festival_values, array($node->field_festival_name['und'][0]['value']));
						domainedo_shows_festival_pathalias_update($previous_festival_values);				
					}
				}
				// If it's NOT THE LATEST ONE
				else {
					// the existing menu link, if any, is deleted
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $node->nid,))->fetchField();
					if ($mlid) {
						menu_link_delete($mlid);
					}
					else {
						dsm('no menu link to delete');
					}
					// and the path alias must be "spectacles/festival-name/season-value".
					$node->path['pathauto'] = 0;
					$node->path['alias'] = 'spectacles/' . $node->field_festival_name['und'][0]['value'] . '/' . $node->field_season['und'][0]['value'];				
					
					// If season value of the festival being updated has changed
					if ($is_season_modified) {
						// and if this festival was the latest one before current update,
						if ($original_previous_festival_values = is_latest_festival($node->original, FALSE)) {
							// The original previous festival will be the latest one after current update.
							// So, we give it a menu link
							$festivals = domainedo_shows_get_festivals();
							$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
							$item = array(
								'link_title' => $festivals[$node->field_festival_name['und'][0]['value']]['title'],
								'link_path' => 'node/' . $original_previous_festival_values[0],
								'menu_name' => 'main-menu:' . $mlid,
								'plid' => $mlid,
								'weight' => $festivals[$node->field_festival_name['und'][0]['value']]['weight'],
							);
							menu_link_save($item);
							
							// and we alter its path alias to "spectacles/festival-name".
							$original_previous_festival_values = array_merge($original_previous_festival_values, array($node->field_festival_name['und'][0]['value']));
							domainedo_shows_festival_pathalias_update($original_previous_festival_values, TRUE);
						}
					}
				}
			}
		}
	}
}

/**
 * Tests if a processed festival ($node) is the more recent one.
 * If yes, returns nid of the previous season's festival, or TRUE if there is no previous festival.
 * If no, return FALSE.
 * 
 * @param Object $node The tested festival.
 * @param Bolean $is_new TRUE is the processed festival is new, otherwise FASLE.
 * @return mixed
 * 	 A boolean TRUE if the processed festival is the latest one and no previous festival exists.
 *   A array ($nid, $season) nid and season values of the previous festival, if any and if the processed festival is the latest one.
 *   A boolean FALSE if the processed festival is not the latest one.
 */
function is_latest_festival($node, $is_new=TRUE) {
	// First, seeks all the registered festivals whose name is $festival_name
	$query = db_select('node', 'n');
	$query->join('field_data_field_festival_name', 'f', 'n.nid = f.entity_id');
	$query->join('field_data_field_season', 's', 'n.nid = s.entity_id');
	
	$query->addField('n', 'nid');
	$query->addField('s', 'field_season_value', 'season');
	$query->condition('n.type', 'festival')
	->condition('f.field_festival_name_value', $node->field_festival_name['und'][0]['value']);
	//->condition('n.status', '1');
	
	// If current process is an update or deletion, the festival node being performed
	// must NOT be retrieved from database to prevent to be compared to itself.
	if(!$is_new) {
		//$query->condition('s.field_season_value', $node->field_season['und'][0]['value'], '<>');
		$query->condition('n.nid', $node->nid, '<>');
	}
	
	$result = $query->execute()->fetchAll();
	
	// If there is no previous festival registered
	if (empty($result)){
		return TRUE;
	}
	
	// else gets the season and nid values of the latest registered festival
	$max_season = 0;
	$previous_nid = 0;
	foreach($result as $festival) {
		if ($festival->season > $max_season) {
			$max_season = $festival->season;
			$previous_nid = $festival->nid;
		}
	}
	
	// Finally, compares theses values to the festival in registration process
	$season_to_save = $node->field_season['und'][0]['value'];
	// If this festival is latest
	if ($season_to_save > $max_season) {
		return array($previous_nid, $max_season);
	}
	// else
	else {
		return FALSE;
	}
}

/**
 * Updates the path alias of a given festival when it is no longer the latest one.
 * Results in adding season value to the end of the existing alias.
 * 
 * @param array $values An array containing the previous festival's nid, season and name values;
 */
function domainedo_shows_festival_pathalias_update($values, $is_latest=FALSE) {
	list($festival_nid, $festival_season, $festival_name) = $values;
	// Delete first the existing path alias
	$old_path = path_load('node/' . $festival_nid);
	path_delete($old_path['pid']);
	// and then save the new one.
	$alias = 'spectacles/' . $festival_name;
	if (!$is_latest) {
		$alias = $alias . '/' . $festival_season;
	}
	$path = array(
			'source' => 'node/' . $festival_nid,
			'alias' => $alias,
	);
	path_save($path);
}

/**
 * Implements hook_node_delete().
 */
function domainedo_shows_node_delete($node) {
	if ($node->type == 'festival') {
		// If latest
		if ($previous_festival_values = is_latest_festival($node, FALSE)) {
			// and if a previous festival exists,
			if(!is_bool($previous_festival_values)) {
				// a menu link is created for this festival
				$festivals = domainedo_shows_get_festivals();
				$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
				$item = array(
					'link_title' => $festivals[$node->field_festival_name['und'][0]['value']]['title'],
					'link_path' => 'node/' . $previous_festival_values[0],
					'menu_name' => 'main-menu:' . $mlid,
					'plid' => $mlid,
					'weight' => $festivals[$node->field_festival_name['und'][0]['value']]['weight'],
				);
				menu_link_save($item);
				
				// and its path alias is updated.
				$festival_values = array_merge($previous_festival_values, array($node->field_festival_name['und'][0]['value']));
				domainedo_shows_festival_pathalias_update($festival_values, TRUE);
			}
		}
	}
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function domainedo_shows_form_festival_node_form_alter(&$form, &$form_state, $form_id) {
	// Move to bottom the vertical tab containing the domaine d'O technical fields.
	// Hey ! Give me a break ! I know there is a typo on 'fiels' (instead of 'fields')
	// but I'm too lazy to delete and recreate the corresponding custom field group in festival content type.
	$form['#groups']['group_technical_fiels']->weight = 1000;
	
	// In edit form only, disables the festival_name field to prevent user to change it.
	if (isset($form_state['node']->nid)) {
		$form['field_festival_name']['#disabled'] = TRUE;
	}
}

/**
 * Implements hook_views_pre_render().
 */
function domainedo_shows_views_pre_render(&$view) {
	if ($view->name == 'shows' && $view->current_display == 'list') {
		$block = module_invoke('views', 'block_view', '-exp-shows-list');
		$view->header['area']->options['content'] = render($block['content']);
	}
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function domainedo_shows_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
       if (isset($form['field_festival_target_id'])) {                
               // Get the id of the latest festival for each festival type.
               $festivals = domainedo_shows_get_festivals();
               $latest_festival_ids = array();
               foreach ($festivals as $name=>$festival) {
                       $latest_festival = domainedo_shows_get_latest_festival_values($name);
                       if ($latest_festival['nid'] != 0) {
                               $latest_festival_ids[$latest_festival['nid']] = $latest_festival['nid'];
                       }
               }
               
               // Compare the exposed festival list and the latest festival list
               // to get rid of festivals not being the latest.
               foreach ($form['field_festival_target_id']['#options'] as $key=>$label) {
                       if (!is_numeric($key)) continue;
                       if (!in_array($key, $latest_festival_ids)) {
                               unset($form['field_festival_target_id']['#options'][$key]);
                       }
               }
               
               $form['field_festival_target_id']['#options']['All'] = t('All upcoming shows');
       }
}

/**
 * Implements hook_menu_block_blocks().
 * Used to export blocks generated by menu_block module (see menu_block_export module).
 */
function domainedo_shows_menu_block_blocks() {
	// $parent_mlid values are different on different Drupal instances (dev, preprod, prod).
	// So we must fetch this value from the database, based on menu link Title (Spectacles in this case).
	$parent_mlid = db_select('menu_links', 'ml')->fields('ml', array('mlid'))->condition('link_title', 'Spectacles')->execute()->fetchField();
	
	return array(
		'domainedo-shows-tab-menu' => array(
				'menu_name'   => 'main-menu',
				'parent_mlid' => $parent_mlid,
				'title_link'  => 0,
				'admin_title' => 'Menu Spectacles à onglets',
				'level'       => 1,
				'follow'      => 0,
				'depth'       => 0,
				'expanded'    => 0,
				'sort'        => 0,
		),
	);
}
